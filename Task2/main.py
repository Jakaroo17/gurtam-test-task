from sys import getsizeof
import timeit
# Импорт библиотек и методов для того чтобы узнать время выполнения и количество памяти, которые используют переменные
input_value = 0x5FABFF01

"""
Разработайте программу, которая из исходного значения 0x5FABFF01 выведет на экран значения дополнительных параметров. 
Первый дополнительный параметр содержится во втором байте исходного значения, 
Второй дополнительный параметр является инверсным значением 7-го бита исходного значения. 
Третий дополнительный параметр является зеркальным отображением 17-20 го бита
(20 бит исходного значения является 1 битом третьего дополнительного параметра, 17 бит исходного значения является 4 битом третьего дополнительного параметра).

0x5FABFF01  =   0101 1111 1010 1011 1111 1111 0000 0001
                                    _________ |   
                                        1^    |
                                            ~2^
                               ____
                               3^ = 1101     
                                
                1000    0000    1111    1111    1101    0101    1111    101
                                
"""

"""СПОСОБ 1. Работа с бинарными числами как со списком символов и переводом в строку. Неэффективно по времени и по используемой памяти (скорее всего), но легкая по реализации
Время выполнения = 2.6499968953430653e-05 сек без вывода промежуточных данных в функции, Память - bin_value = 312 байт
                   0.00073640001937747  сек   c  выводом                                          first_param = 56 байт
                                                                                                  second_param = 28 байт
                                                                                                  third_param = 88 байт
                                                                                                  [firs_param,second_param,third_param] = 144 байт
"""

def first_way():
    bin_value = ['0'] + list(bin(input_value))[2::] # перевод исходного значения в список из бинарных чисел, bin возвращает строку, тоесть bin(15) = "0b1111". 
                                                    # Срез списка [2::] необходим для того чтобы убрать 0b 
    bin_value = bin_value[::-1] # Инверсия списка для удобства обращения к индексам
    firs_param = str.join('',(bin_value[8:15])) # Получаения среза списка с 7 по 15 бит и объединение этого в строку
    # print(firs_param)
    second_param = ~int(bin_value[6])*-1 #Получение 7 бита и инверсия его. *-1 необходимо для того чтобы было положительное значение
    # print(second_param)
    third_param = bin_value[16:20] #Получения среза списка с 17 по 20 элемент. Отзеркаливать его не надо, так как мы сделали это в 35 строке
    # print(third_param)
    return [firs_param,second_param,third_param]


print(f"first_way: {timeit.timeit(first_way,number=1)}") #ВЫвод времени выполнения
print(getsizeof(first_way)) # Вывод количество памяти, которое занимает результат

"""СПОСОБ 2. Битовые операции и битовые сдвиги. Эффективно по времени и по памяти, но сложнее в реализации
Время выполнения = 7.2999391704797745e-06 сек без вывода промежуточных данных в функции, Память - 
                   0.0005537000251933932  сек   c  выводом                                        first_param = 28 байт
                                                                                                  second_param = 28 байт
                                                                                                  third_param = 28 байт
                                                                                                  [firs_param,second_param,third_param] = 144 байт

"""
# Функция для зеркального побитого отражения бинарного числа
def reverse_bit(num):
    result = 0
    while num:
        result = (result << 1) + (num & 1)
        num >>= 1
    return result

def second_way():
    first_param = (65280 & input_value) >> 8 # 65280 или 1111 1111 0000 0000 - маска, с которой происходит конъюнкция. После делаем 8 битовых сдвигов вправо для получения первого параметра
    # print(first_param)

    second_param = ((input_value >> 6) & 0 )| 1 # Делаем 6 битовых сдвига вправо, конъюкцию с нулем и дизъюнкцию с единицей для инверсии 7 бита
    # print(second_param)
    third_param = input_value >> 4*4 #Делаем 16 битовых сдвигов вправо, зеркально отражаем число и 11 битовых сдвигов право
    third_param = reverse_bit(third_param) >> 2*4+3
    # print(third_param)
    return [first_param,second_param,third_param]

print(f"second_way: {timeit.timeit(second_way,number=1)}") #Вывод времени выполнения
print(getsizeof(second_way)) # Вывод количество памяти, которое занимает результат